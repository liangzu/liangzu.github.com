<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-05-28 六 19:43 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>编译器中的数据结构</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Liangzu Peng" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="./css/my-css.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">编译器中的数据结构</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">Overview</a>
<ul>
<li><a href="#orgheadline2">Prerequisites</a></li>
<li><a href="#orgheadline3">parser运行流程</a></li>
<li><a href="#orgheadline4">您的任务</a></li>
</ul>
</li>
<li><a href="#orgheadline5">Parser程序</a>
<ul>
<li><a href="#orgheadline6">词法分析</a></li>
<li><a href="#orgheadline7">语法分析</a></li>
<li><a href="#orgheadline8">测试文件</a></li>
<li><a href="#orgheadline9">除了c++代码之外的其它文件(不是很重要)</a></li>
<li><a href="#orgheadline10">接口</a></li>
</ul>
</li>
<li><a href="#orgheadline11">语法树</a>
<ul>
<li><a href="#orgheadline12">common.h</a></li>
<li><a href="#orgheadline13">Tree.h/cpp</a></li>
</ul>
</li>
<li><a href="#orgheadline14">符号表</a>
<ul>
<li><a href="#orgheadline15">实现</a></li>
<li><a href="#orgheadline16">接口</a></li>
</ul>
</li>
<li><a href="#orgheadline17">建议</a></li>
<li><a href="#orgheadline18">Conclusion</a></li>
<li><a href="#orgheadline19">附：cfg</a></li>
</ul>
</div>
</div>
<blockquote>
<p>
"您应该拥有自己的语法树。"
</p>
</blockquote>

<p>
跟完编译器课程后，用cool project自带的语法树完成编译器的语义分析和代码生成还是挺爽的。可是后来我看了这么多各种各样的语法树，我突然对自己说：“彭良祖，您应该拥有自己的语法树”。所以
在本校编译器课程的这次团队作业中呢，我选择了做语法树的任务。我发现给队友写的parser文档除了具有纪念价值外还有教育意义。故将它放出来。对编译器感兴趣的入门级读者应关注:
</p>
<ul class="org-ul">
<li><b>Parser运行流程</b> 小节</li>
<li><b>Tree.h/cpp</b> 小节</li>
<li><b>符号表</b> 小节</li>
</ul>

<p>
这三小节分别介绍了flex, bison的一些常见使用问题、语法树数据结构以及符号表数据结构。
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Overview</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
这份文档将介绍我的工作，主要的注重点是讲述各种文件的构成及内容，帮助您熟悉、使用我的程序。为语义分析和类型检查提供方便。
</p>

<p>
信息量可能比较大，但是您必须要认真地（并且可能需要结合其它文件内容、反复地）阅读，否则很难知道从哪开始做自己的工作。我尽量写得简洁但是不遗漏。
</p>

<p>
为方便起见，做如下约定：
</p>
<ul class="org-ul">
<li>下文中所有提到的文件位置，如未特殊说明，默认的父目录是 <i>parser</i> 目录。</li>
<li>词法分析文件简称为.l文件，语法分析文件简称为.ypp文件。</li>
<li>词法分析程序简称为lex程序，语法分析程序简称为bison程序,两者一起统称为parser程序。</li>
<li>文中的"我们"和"您"是为了增强带入感和提升我写文档的体验，可酌情忽略。</li>
<li>下文中会有一些关键字： <b>注意</b> 和 <b>警告</b> 。它们所指示的内容是我认为重要的。它们的重要程度由其本身的词义所标识。</li>
</ul>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">Prerequisites</h3>
<div class="outline-text-3" id="text-orgheadline2">
<dl class="org-dl">
<dt>c++及其编译器</dt><dd>我所使用的编程语言,我在代码中使用了标准库容器、继承、虚函数和模板，您应当对它们熟悉。</dd>
<dt>flex, bison的库</dt><dd>编译必备</dd>
<dt><a href="http://www.graphviz.org/">Graphviz</a> (optional)</dt><dd>可以生成图片，通过 <code>Print</code> 函数可以很方便的“看到"语法树，用来DEBUG。它所使用的脚本语言叫做 <b>Dot</b>.</dd>
<dt>cmake (optional)</dt><dd>您可以使用您喜欢的编辑器和编译方式</dd>
</dl>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">parser运行流程</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
lex程序会生成 <code>yylex()</code> 函数，该函数将源程序解析成一个一个的token; bison程序会生成一个函数: <code>yyparse()</code>, 该函数会调用 <code>yylex()</code> 函数进行语法分析。
</p>

<p>
其中比较值得注意的问题有：
</p>
<dl class="org-dl">
<dt>.l文件中并没有定义token?</dt><dd>对。它的定义在.ypp文件里。所以需要在.l文件中包含bison程序所生成的c++文件(<code>/src/SyntaxAnalyzer.hpp</code>).</dd>
<dt>.ypp文件中并没有定义语法树?</dt><dd>对。它的定义在 <code>/src/Tree.h</code> 文件里。所以同上。</dd>
<dt>.l和.ypp文件中没有解析文法里的SYS-FUNC和SYS-PROC?</dt><dd>对。它们被当作identifier在.l文件中被识别。它们的使用和普通函数/过程调用语法是一致的，所以在.ypp文件中被当作普通func/proc被识别。我们需要在语义分析阶段把它们加到全局符号表中(java里那种预定义的Object对象也是这么来的)。</dd>
<dt>parser程序是如何读取文件的？</dt><dd>默认情况下，parser程序会读标准输入。我们可以通过改变 <code>yyin</code> 这个文件指针(外部变量)来改变输入流。见.ypp文件首部和尾部。</dd>
<dt>parser程序是如何报错的？</dt><dd>bison程序如果发现了语法错误，会调用 <code>yyerror()</code> 函数报导错误。我给的错误信息十分简洁。见.l文件尾部。</dd>
<dt>是否需要在链接时加载flex,bison库？</dt><dd>我看到一些比较旧的教程说链接时要打 <code>-ly</code>, <code>-lfl</code> 这种命令加载flex, bison库，但是我的电脑上并不需要。我电脑上的版本是： bison3.0.4, flex2.6.1</dd>
</dl>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">您的任务</h3>
<div class="outline-text-3" id="text-orgheadline4">
<ul class="org-ul">
<li>简要地看.l文件大致了解词法分析做了些什么。</li>
<li>关注.ypp文件是如何建立语法树的。</li>
<li>重点关注符号表的接口及其实现。</li>
<li>重点关注语法树结构，以及我写的 <code>Name()</code> 函数的使用。以此了解如何使用我的语法树。</li>
<li>完成类型检查（or 代码生成）的工作。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">Parser程序</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
警告： <b>无需修改</b>.
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">词法分析</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
即 <code>lex.l</code> 文件。
</p>

<p>
注意： 
</p>
<ul class="org-ul">
<li>不含对 "goto" 这个token的提取。</li>
<li>无法识别转义的字符串。例如，lex程序遇到 'abc\nabc' 的时候，其实把 '\n' 读到内存里变成了 '\\n'，而我们清楚地知道它的实际含义是换行符, 即在内存里应该是 '\n'。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">语法分析</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
即 <code>syntax.ypp</code> 文件。
</p>

<p>
注意： 
</p>
<ul class="org-ul">
<li>不含对 "goto" 语法的分析。</li>
<li>生成的语法树节点中没有记录行号。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">测试文件</h3>
<div class="outline-text-3" id="text-orgheadline8">
<dl class="org-dl">
<dt><code>/test/*.pas</code></dt><dd>输入文件，从github上剽窃而来。符合老师所给cfg的源程序，但是不一定符合其语义。</dd>
<dt><code>/test/*.dot</code></dt><dd>调用 <code>Print函数</code> 后的输出文件， dot脚本， 用于编译生成图片。</dd>
<dt><code>/test/*.pdf</code></dt><dd>编译dot脚本后生成的图片。</dd>
</dl>

<p>
您需要：
</p>
<ul class="org-ul">
<li>对照 <code>test.pas</code> 和 <code>test.pdf</code> 的异同来发现我的程序的正确性(or错误)。</li>
<li>可能需要写自己的测试文件，比如语法正确但是语义错误的pascal程序。</li>
</ul>

<p>
注意： <b>符合pascal语法的源文件并不一定能被parser程序识别，因为老师给的cfg其实是pascal的简化版，如果您写的测试输入文件不能通过parser，则需要对照错误信息、.ypp、.l文件修正自己的输入文件。不建议修改parser程序。如果输入程序符合老师的cfg却不能通过编译应及时与队友们沟通。</b> 
</p>


<p>
调用 <code>Program::Print()</code> 函数会在可执行文件目录生成 <code>tree.dot</code> 脚本文件。如果您想要"看"到您输入文件所生成的语法树，您需要安装好 <b>Graphviz</b> （见上文），并知道简单的编译dot脚本的命令。例如:
</p>
<div class="org-src-container">

<pre class="src src-sh">dot -Tpdf -o tree.pdf tree.dot <span style="color: #2aa1ae; background-color: #292e34;">#</span><span style="color: #2aa1ae; background-color: #292e34;">or</span>
dot -Tjpg -o <span style="color: #4f97d7;">[</span>your-favorite-output-filename<span style="color: #4f97d7;">]</span> <span style="color: #4f97d7;">[</span>input-dot-file<span style="color: #4f97d7;">]</span>
</pre>
</div>

<p>
注意： 因为文法被我改了，语法树节点不再有优先级信息，所以我打印出来的表达式都是前缀表达式。但是后来我想……其实中缀表达式也是可以的，因为语法树的结构已经是那个样子了。不过我懒得改回中缀表达式了:P
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">除了c++代码之外的其它文件(不是很重要)</h3>
<div class="outline-text-3" id="text-orgheadline9">
<ul class="org-ul">
<li><code>build-parser.sh</code> 是一个简单的flex,bison编译脚本，编译完.l,.ypp文件后，将生成的c++源文件移动到 <code>/src</code> 目录</li>
<li><code>/cache/SyntaxAnalyzer.pdf</code> 是bison生成的状态机</li>
<li><code>/cache/SyntaxAnalyzer.dot</code> 是dot脚本文件</li>
<li><code>/cache/SyntaxAnalyzer.output</code> 是整个parsing算法的状态转移表</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">接口</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
您只需要调用 <code>Parse(const char* filename)</code> 即可得到一颗语法树(见 <code>/src/main.cpp</code>)。 例如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #4f97d7; font-weight: bold;">auto</span> <span style="color: #ce537a; font-weight: bold;">root</span> = Parse<span style="color: #4f97d7;">(</span>filename<span style="color: #4f97d7;">)</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11">语法树</h2>
<div class="outline-text-2" id="text-orgheadline11">
<p>
从下文开始，我们进入 <code>/src/</code> 目录。
</p>

<p>
通过调用 <code>Parse(const char*)</code> 函数后，我们就得到了一颗语法树。下面将对它进行介绍。
</p>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">common.h</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
注意： 您可以在本文件中添加您需要的元素，但尽量不要修改它原有的内容。
</p>

<p>
警告： <b>您必须理解</b> <code>common.h</code> <b>里前80行的代码</b> 才能理解 <code>Tree.h</code> 以及.ypp文件里的代码。
</p>

<dl class="org-dl">
<dt>20-32行</dt><dd>定义了一些三个别名。看起来可能略显奇葩，其实我本来用的是 <code>shared_ptr</code>,但是.ypp文件会给我报错。所以改成了现在这个样子。</dd>
<dt>36-78行</dt><dd>定义了一个 <code>Symbol</code> 类，它的目的是作为一个'符号',可以充当符号表的key&#x2026;我在语法树节点里面也有使用它。</dd>
<dt>80行之后</dt><dd><code>ListToStr</code> 是我用于打印输出的一个辅助函数，后面的部分可能可以删去，但是我懒得搞了。</dd>
</dl>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">Tree.h/cpp</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
注意： 
</p>
<ul class="org-ul">
<li>您需要查看 <code>Tree.h</code> 里面所有的代码、.ypp文件里的代码以及cfg（文末）。要确保自己理解了语法树的结构，再在此基础上做类型检查或代码生成。</li>
<li>如果您认为需要改动语法树结构则需跟队员们协商。</li>
<li>本语法树结构使用的是裸指针，没有任何内存管理，反正程序只需要run一次。我们可以把c++当作有gc的语言。</li>
</ul>

<p>
这是语法树的数据结构所在之处。语法分析的结果是把程序结构存储到内存当中，用来存储它的数据结构是见仁见智的,只要我们有办法能够在内存里面引用到它们并且利用它们干点什么事就可以了。
在介绍我的语法树之前，先向您展示两种不同的语法树。只要看示例代码就应该能发现它们的异同了。
</p>
<pre class="example">
/* c-style AST */
Statement* NewStmtNode(kind nodeKind, /*some other arguments*/) {
    // InitAndReturn();
}
struct Statement 
{
    enum kind { IF, WHILE /* and other stmts */ }

    // other members.
};
// the below function is used to do something with statement node
void DoSomething(/*arguments*/) {
    if (kind == IF)
        // do something..
    else if (kind == WHILE)
        // do something else
}

/* OO-style AST */
struct Statement
{
    virtual void DoSomething() {};
};
struct If: Statement
{
    virtual void DoSomething() {};

    If(/* some other arguments */) {};
};
struct While: Statement
{
    // the same structure as If, with different arguments.
}
</pre>
<p>
这两种语法树实现方式是不一样的，但是无论是哪个，我们总能调用 <code>Statement::DoSomething()</code> 来对语法树节点进行操作，其结果也是一样的。
</p>

<p>
我在 <code>Tree.h</code> 里采用的做法是第二种， 因为第一种做法会使一个结构体或者类里的东西变得很多很杂(外国佬称这种类为 <code>Blob class</code>)。而用第二种结构我们就清楚地知道要对谁做什么事情。
我可以在 <code>Statement</code> 所有子类中实现相同的函数接口(e.g., <code>TypeChecking()</code>, <code>CodeGeneration()</code>)，比较方便的就是我在写这些函数的时候已经知道了我们要操作的是什么(我写在 <code>If</code> 类里面的函数就是操纵
<code>If</code> 这个节点的)，而不用再去一个一个问"你是什么节点"，再采取相应的操作， 虚函数则保证了我们调用基类的函数会准确地链接到该指针所指对象的那个函数. 它的缺点就是导致一个语法树有很多个 <code>struct</code> 。
</p>

<p>
有几点需要特别指出的是：
</p>
<ul class="org-ul">
<li>由于文法无法识别无参函数调用和identifier：它们在文法中都是identifer,不像c语言无参数函数调用是 <code>f()</code>, 而变量是 <code>f</code>, pascal就都是 <code>f</code>.所以有一个语法树节点叫 <code>struct IdOrFunc： Expr</code>.</li>
<li>pacsal的函数有返回值，而过程没有，所以它们在文法中的体现是：函数调用是一个表达式，过程调用则是一个状态(表达式有返回值而状态没有）。在语法树中的体现是： <code>struct Func: Expr</code> 表示函数调用节点, <code>struct Proc: Statement</code> 表示过程调用节点。</li>
<li>由于以上原因， <code>Func</code> 节点的参数列表永远不可能是 <code>nullptr</code>, 无参函数在 <code>IdOrFunc</code> 节点中。 而 <code>Proc</code> 节点的参数列表则可能是空的。</li>
<li>您应当搜索 <code>Tree.h</code> 和.ypp文件中 <code>nullptr</code> 出现的位置。这样您才会理解对于哪些节点或list，我们要用 <code>!node</code> 来检查，对于哪些节点或list，我们要用 <code>list-&gt;empty</code> 来检查。 或者最稳妥的做法是 这两句同时写。</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">符号表</h2>
<div class="outline-text-2" id="text-orgheadline14">
<p>
注意： 可自行修改 <code>Symboltable.h</code> 里的内容。您可能希望、我们也鼓励您使用自己的符号表。但我们仍然建议您去查看 <code>Symboltable.h</code> 里的代码。由于符号表的实现比较简单，所以我并没有对此进行测试:P
</p>

<p>
警告： 您必须在类型检查之前进行"初始化"，即把一些预定义系统函数/过程添加到符号表中，请查看老师给的cfg以明确需要添加哪些系统函数进去。
</p>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">实现</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
符号表给人的第一感觉就是一个key-value的映射。但是在程序语言作用域的影响下，编译器的符号表发生了一些变化。在编译器的实现中，
符号表首先是一个栈(<code>Stack</code>),栈顶代表当前的作用域(<code>Scope</code>),进入、退出作用域就相当于对栈顶元素的操作(<code>push</code>, <code>pop</code>)了。
栈里的元素是 <code>std::map</code>, 意思是每个作用域都有一个自己的符号表。
</p>

<p>
由于语法树节点的类型均为指针，所以符号表的value类型是指针的话会比较方便，key类型您可以选择使用 <code>Symbol</code> 类， 或者是您喜欢的任何有标记作用的类型。
我们可能会希望建立多个符号表，比如：变量声明的符号表，常量声明的符号表&#x2026;这样类型检查会方便很多。所以最好还是给 <code>Symboltable</code> 套一个模板参数。
</p>

<p>
里边还定义了 <code>EmptyScopeException</code> 异常类, 用来发现对符号表的错误操作的情况。 
</p>
</div>
</div>


<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">接口</h3>
<div class="outline-text-3" id="text-orgheadline16">
<dl class="org-dl">
<dt><code>void EnterScope()</code></dt><dd>进入作用域。</dd>
<dt><code>void ExitScope()</code></dt><dd>退出作用域。</dd>
<dt><code>Lookup(Symbol s)</code></dt><dd>从栈顶开始查找符号 <code>s</code>, 搜索整个作用域。</dd>
<dt><code>AddSymbol(Symbol s, Data d)</code></dt><dd>将符号s以及它所对应的数据加到符号表中。</dd>
<dt><code>Probe(Symbol s)</code> </dt><dd>查找符号 <code>s</code>, 只搜索当前作用域。</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17">建议</h2>
<div class="outline-text-2" id="text-orgheadline17">
<p>
由于代码生成和类型检查之间并无相关性（我们可以生成语义错误的代码然后导致一些未定义行为），实际上，可以认为 <code>Program::Print</code> 函数就是简单的代码生成。
</p>

<p>
所以这两部分的工作可以同时展开。
</p>

<p>
对于类型检查的建议是:
</p>
<ul class="org-ul">
<li>记得"初始化"(见前文)!</li>
<li>由于类型检查比较繁琐，要检查的点很多，所以需要明确地分隔自己的任务，需要自己动手写语法正确但是语义错误的文件加以测试。</li>
</ul>

<p>
对于代码生成的建议是(感觉这个可能是最难的点了)：
</p>
<ul class="org-ul">
<li>最简单的做法是采用<a href="https://en.wikipedia.org/wiki/Stack_machine">Stack Machine</a>模型：只使用一个寄存器和一个临时变量，维持栈invariant, 这样就不需要考虑寄存器分配算法了。</li>
<li>自底向上地代码生成：从简单表达式的代码生成，(e.g., plus, minus), 到各种循环语句，再到函数调用。</li>
<li>您可能需要再回顾mips的一些指令.</li>
<li>需要使用mips的模拟器。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18">Conclusion</h2>
<div class="outline-text-2" id="text-orgheadline18">
<p>
总而言之，您必须:
</p>
<ol class="org-ol">
<li>熟悉语法树结构，理解 <code>/src/Tree.h</code> 和.ypp文件的代码。</li>
<li>做自己的工作。</li>
</ol>

<p>
您需要在其中添加代码的文件是:
</p>
<ul class="org-ul">
<li><code>/src/Tree.h</code> (为每个节点添加类型检查和代码生成的函数)。</li>
<li><code>/src/Tree.cpp</code></li>
</ul>

<p>
您可能需要修改的文件是：
</p>
<ul class="org-ul">
<li><code>/src/common.h</code></li>
</ul>

<p>
您可能需要修改和测试的内容是:
</p>
<ul class="org-ul">
<li><code>/src/Symboltable.h</code></li>
</ul>

<p>
希望我把自己的工作讲清楚了，也希望本文档能够帮助您更好地完成后续工作。
</p>
</div>
</div>


<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19">附：cfg</h2>
<div class="outline-text-2" id="text-orgheadline19">
<p>
您需要对照此cfg和老师的cfg，并理解其中的差异。
</p>
<pre class="example">
  1 program: PROGRAM IDENTIFIER SEMI const_part type_part var_part routine_part routine_body DOT

  2 sub_routine: const_part type_part var_part routine_part routine_body

  3 const_part: CONST const_expr_list
  4           | %empty

  5 const_expr_list: const_expr_list IDENTIFIER EQUAL const_value SEMI
  6                | IDENTIFIER EQUAL const_value SEMI

  7 const_value: INTEGER
  8            | REAL
  9            | STRING
 10            | BOOL
 11            | MAXINT

 12 type_part: TYPE type_decl_list
 13          | %empty

 14 type_decl_list: type_decl_list IDENTIFIER EQUAL type_decl SEMI
 15               | IDENTIFIER EQUAL type_decl SEMI

 16 type_decl: simple_type_decl
 17          | array_type_decl
 18          | record_type_decl

 19 simple_type_decl: SYS_TYPE
 20                 | IDENTIFIER
 21                 | LP name_list RP
 22                 | INTEGER DOTDOT INTEGER
 23                 | MINUS INTEGER DOTDOT INTEGER
 24                 | MINUS INTEGER DOTDOT MINUS INTEGER
 25                 | IDENTIFIER DOTDOT IDENTIFIER

 26 array_type_decl: ARRAY LB simple_type_decl RB OF type_decl

 27 record_type_decl: RECORD field_decl_list PEND

 28 field_decl_list: field_decl_list field_decl
 29                | field_decl

 30 field_decl: name_list COLON type_decl SEMI

 31 name_list: name_list COMMA IDENTIFIER
 32          | IDENTIFIER

 33 var_part: VAR var_decl_list
 34         | %empty

 35 var_decl_list: var_decl_list name_list COLON type_decl SEMI
 36              | name_list COLON type_decl SEMI

 37 routine_part: routine_part function
 38             | routine_part procedure
 39             | function
 40             | procedure
 41             | %empty

 42 function: FUNCTION IDENTIFIER parameters COLON simple_type_decl SEMI sub_routine SEMI

 43 procedure: PROCEDURE IDENTIFIER parameters SEMI sub_routine SEMI

 44 parameters: LP para_decl_list RP
 45           | %empty

 46 para_decl_list: para_decl_list SEMI para_type_list
 47               | para_type_list

 48 para_type_list: VAR name_list COLON simple_type_decl
 49               | name_list COLON simple_type_decl

 50 routine_body: compound_stmt

 51 stmt_list: stmt_list stmt SEMI
 52          | %empty

 53 stmt: assign_stmt
 54     | proc_stmt
 55     | compound_stmt
 56     | if_stmt
 57     | repeat_stmt
 58     | while_stmt
 59     | for_stmt
 60     | case_stmt

 61 assign_stmt: IDENTIFIER ASSIGNMENT expr
 62            | IDENTIFIER LB expr RB ASSIGNMENT expr
 63            | IDENTIFIER DOT IDENTIFIER ASSIGNMENT expr

 64 proc_stmt: IDENTIFIER
 65          | IDENTIFIER LP expr_list RP

 66 compound_stmt: PBEGIN stmt_list PEND

 67 if_stmt: IF expr THEN stmt else_clause

 68 else_clause: ELSE stmt
 69            | %empty

 70 repeat_stmt: REPEAT stmt_list UNTIL expr

 71 while_stmt: WHILE expr DO stmt

 72 for_stmt: FOR IDENTIFIER ASSIGNMENT expr TO expr DO stmt
 73         | FOR IDENTIFIER ASSIGNMENT expr DOWNTO expr DO stmt

 74 case_stmt: CASE expr OF case_expr_list PEND

 75 case_expr_list: case_expr_list case_expr
 76               | case_expr

 77 case_expr: const_value COLON stmt SEMI
 78          | IDENTIFIER COLON stmt SEMI

 79 expr_list: expr_list COMMA expr
 80          | expr

 81 expr: expr GE expr
 82     | expr GT expr
 83     | expr LE expr
 84     | expr LT expr
 85     | expr EQUAL expr
 86     | expr UNEQUAL expr
 87     | expr PLUS expr
 88     | expr MINUS expr
 89     | expr OR expr
 90     | expr MUL expr
 91     | expr DIV expr
 92     | expr MOD expr
 93     | expr AND expr
 94     | IDENTIFIER
 95     | IDENTIFIER LP expr_list RP
 96     | const_value
 97     | LP expr RP
 98     | NOT expr
 99     | MINUS expr
100     | IDENTIFIER LB expr RB
101     | IDENTIFIER DOT IDENTIFIER
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Liangzu Peng (<a href="mailto:faithofplz@hotmail.com">faithofplz@hotmail.com</a>)</p>
<p class="date">Date: 2016-05-28 六 19:40</p>
</div>
</body>
</html>
