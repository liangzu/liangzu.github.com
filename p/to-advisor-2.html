<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ImageWarping Report</title>
<!-- 2017-02-27 Mon 13:42 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Liangzu Peng" />
<link rel="stylesheet" href="./css/my-css.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ImageWarping Report</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Code</a>
<ul>
<li><a href="#sec-1-1">Download</a></li>
<li><a href="#sec-1-2">Compilation</a></li>
<li><a href="#sec-1-3">Running</a></li>
<li><a href="#sec-1-4">Usage</a></li>
</ul>
</li>
<li><a href="#sec-2">Introduction</a></li>
<li><a href="#sec-3">Implementation</a>
<ul>
<li><a href="#sec-3-1">IDW</a>
<ul>
<li><a href="#sec-3-1-1">Implementing &omega;<sub>i</sub>(p)</a></li>
<li><a href="#sec-3-1-2">implementing &fnof;<sub>i</sub>(p)</a></li>
</ul>
</li>
<li><a href="#sec-3-2">RBF</a>
<ul>
<li><a href="#sec-3-2-1">Implementing P<sub>m</sub>(p)</a></li>
<li><a href="#sec-3-2-2">Implementing &fnof;<sub>i</sub>(d(p, p<sub>i</sub>))</a></li>
<li><a href="#sec-3-2-3">Implementing &alpha;<sub>i</sub>(p)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Result</a></li>
<li><a href="#sec-5">Finally Fragmentary Thinking (FFT)</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Code</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Download</h3>
<div class="outline-text-3" id="text-1-1">
<p>
链接: <a href="https://pan.baidu.com/s/1kVAy043">https://pan.baidu.com/s/1kVAy043</a> 密码: 6qz5
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Compilation</h3>
<div class="outline-text-3" id="text-1-2">
<p>
My environment is Qt Creator 4.2.1 based on Qt 5.8.0. The path to
opencv and eigen library/header in <b>.pro</b> file should be set correctly.
</p>

<dl class="org-dl">
<dt> Note1 </dt><dd>   The process of compiling will introduce some warnings, which have
turn out to be no harm to the correctness of the program.
</dd>
<dt> Note2 </dt><dd>I tried to use opencv after finishing the task of Qt
version. But I found that the code I need to write is
similar, the only thing I need to be careful is the
difference of <b>Mat</b> and <b>QImage</b>. I promise that I've
known how to use <b>Mat</b> just like how I use <b>QImage</b>, so I
didn't write the opencv version.
</dd>
</dl>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Running</h3>
<div class="outline-text-3" id="text-1-3">
<p>
click 'run' in Qt Creator.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Usage</h3>
<div class="outline-text-3" id="text-1-4">
<ol class="org-ol">
<li>Open an image,
</li>
<li>click 'Change Mode' to change mode from <code>normal_mode</code> to <code>drawing_control_points</code>.
</li>
<li>draw control points on the <b>left</b> image,
</li>
<li>click 'IDW Method' or 'RBF Method',
</li>
<li>See the result on the <b>right</b> image.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Introduction</h2>
<div class="outline-text-2" id="text-2">
<p>
  Image Warping problem is basically finding a mapping &fnof;: &real;<sup>2</sup>
&rarr; &real;<sup>2</sup> to warp images. In this task, I implemented two
algorithms, IDW and RBF, both of which use control points to find
the mapping function &fnof;. The difficulty of this task is obviously
not the implementation of algorithms, but the formulas. To
understand the formulas, I tried several methods, which turned out
to be helpful:
</p>
<ul class="org-ul">
<li>find out the type of the variables(e.g., scalar or vector),
</li>
<li>figure out the type of the function(its input and output),
</li>
<li>implement a small part of the formulas first to get some feelings.
</li>
<li>draw simple graphs(by brain or by hand) to understand it geometrically.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Implementation</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">IDW</h3>
<div class="outline-text-3" id="text-3-1">
<div class="center">
<p>
&fnof;(p) = &sum;&omega;<sub>i</sub>(p)&times;&fnof;<sub>i</sub>(p)
</p>
</div>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Implementing &omega;<sub>i</sub>(p)</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
A wise boy should get himself started by implementing &omega;<sub>i</sub>(p)
function,
</p>
<div class="center">
<p>
&omega;<sub>i</sub>(p)=&sigma;<sub>i</sub>(p) / &sum;<sub>j=1-n</sub> &sigma;<sub>j</sub>(p)
</p>
</div>
<p>
whose input is
</p>
<ul class="org-ul">
<li>a control point <b>p</b> obviously (it slept in the "()"),
</li>
<li>an subscript <b>i</b>! it hid itself at a lower position!

<p>
The observations above leads directly to our implementation:
</p>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7FFFD4;">double</span> <span style="color: #1D68C4;">wi</span><span style="color: #e91e63;">(</span><span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">p</span>, <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
    <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;
    <span style="color: #5FB7CC;">if</span> <span style="color: #1565C0;">(</span>sz &lt; i<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        <span style="color: #5FB7CC;">return</span> -1.0;   <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">error, but will never happen in this program.</span>
    <span style="color: #1565C0;">}</span>

    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">type of control_points: vector&lt;pair&lt;QPoint, QPoint&gt;&gt;</span>
    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">first: p; second: q</span>
    <span style="color: #5FB7CC;">if</span> <span style="color: #1565C0;">(</span>p == control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        <span style="color: #5FB7CC;">return</span> 1.0;    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">p is a control point.</span>
    <span style="color: #1565C0;">}</span>


    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">num</span> = sigma<span style="color: #1565C0;">(</span>p, control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first<span style="color: #1565C0;">)</span>;

    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">den</span> = 0.0;
    <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">j</span> = 0; j &lt; sz; ++j<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        den += sigma<span style="color: #EF6C00;">(</span>p, control_points<span style="color: #B388FF;">[</span>j<span style="color: #B388FF;">]</span>.first<span style="color: #EF6C00;">)</span>;
    <span style="color: #1565C0;">}</span>

    <span style="color: #5FB7CC;">return</span> num / den;
<span style="color: #e91e63;">}</span>
</pre>
</div>

<p>
I made the task easier after noticing that two input mentioned
above. The rest of my programs followed this pattern.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">implementing &fnof;<sub>i</sub>(p)</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
At first, I wanted to find <b>&fnof;<sub>i</sub>(p)</b> by minimizing the squared
error <b>E<sub>i</sub>(T) = &sum; &sigma;<sub>ij</sub>&vert;&fnof;<sub>i</sub>(p) - q<sub>j&vert;</sub><sup>2</sup></b> under the
assumption of <b>&fnof;<sub>i</sub>(p) = q<sub>i</sub> + T<sub>i</sub>(p - p<sub>i</sub>)</b>, which requires
solving a system of equations to find T<sub>i</sub>. The below is my
effort:
</p>
<div class="org-src-container">

<pre class="src src-c++">      <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">to find out fi, we need to solve a system of equations: E * t = e</span>
    <span style="color: #7FFFD4;">Matrix2d</span> <span style="color: #1D68C4;">E</span><span style="color: #e91e63;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
        <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;

        <span style="color: #7FFFD4;">Matrix2d</span> <span style="color: #ffffaa;">e</span>;
        <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">I don't know about the constructor of Matrix2d</span>
        e<span style="color: #1565C0;">(</span>0, 0<span style="color: #1565C0;">)</span> = e<span style="color: #1565C0;">(</span>0, 1<span style="color: #1565C0;">)</span> = e<span style="color: #1565C0;">(</span>1, 0<span style="color: #1565C0;">)</span> = e<span style="color: #1565C0;">(</span>1, 1<span style="color: #1565C0;">)</span> = 0.0;
        <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">j</span> = 0; j &lt; sz; ++j<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
            <span style="color: #5FB7CC;">if</span> <span style="color: #EF6C00;">(</span>i == j<span style="color: #EF6C00;">)</span> <span style="color: #EF6C00;">{</span>
                <span style="color: #5FB7CC;">continue</span>;
            <span style="color: #EF6C00;">}</span>

            <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">this loop is short, don't care about the repeated calculation.</span>
            e<span style="color: #EF6C00;">(</span>0, 0<span style="color: #EF6C00;">)</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dpx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>;
            e<span style="color: #EF6C00;">(</span>0, 1<span style="color: #EF6C00;">)</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dpy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>;
            e<span style="color: #EF6C00;">(</span>1, 0<span style="color: #EF6C00;">)</span> += e<span style="color: #EF6C00;">(</span>0, 1<span style="color: #EF6C00;">)</span>;
            e<span style="color: #EF6C00;">(</span>1, 1<span style="color: #EF6C00;">)</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dpy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>;

        <span style="color: #1565C0;">}</span>

        <span style="color: #5FB7CC;">return</span> e;
    <span style="color: #e91e63;">}</span>

    <span style="color: #7FFFD4;">Matrix2d</span> <span style="color: #1D68C4;">ti</span><span style="color: #e91e63;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
        <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;

        <span style="color: #7FFFD4;">Vector2d</span> <span style="color: #ffffaa;">e1</span>, <span style="color: #ffffaa;">e2</span>;
        e1<span style="color: #1565C0;">[</span>0<span style="color: #1565C0;">]</span> = e1<span style="color: #1565C0;">[</span>1<span style="color: #1565C0;">]</span> = e2<span style="color: #1565C0;">[</span>0<span style="color: #1565C0;">]</span> = e2<span style="color: #1565C0;">[</span>1<span style="color: #1565C0;">]</span> = 0.0;
        <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">j</span> = 0; j &lt; sz; ++j<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
            <span style="color: #5FB7CC;">if</span> <span style="color: #EF6C00;">(</span>i == j<span style="color: #EF6C00;">)</span> <span style="color: #EF6C00;">{</span>
                <span style="color: #5FB7CC;">continue</span>;
            <span style="color: #EF6C00;">}</span>

            <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">this loop is short, repeated computations don't matter... or do they?</span>
            e1<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dqx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>; <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">dqx(i, j) in the paper</span>
            e1<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dqx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>;

            e2<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpx<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dqy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>; <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">dqy(i, j) in the paper.</span>
            e2<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> += sigma<span style="color: #EF6C00;">(</span>i, j<span style="color: #EF6C00;">)</span> * dpy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span> * dqy<span style="color: #EF6C00;">(</span>j, i<span style="color: #EF6C00;">)</span>;
        <span style="color: #1565C0;">}</span>

        <span style="color: #7FFFD4;">Matrix2d</span> <span style="color: #ffffaa;">result</span>;
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">ColPivHouseholderQR&lt;Matrix2d&gt; QRed_E(E(i));</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">Vector2d t1 = QRed_E.solve(e1);</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">Vector2d t2 = QRed_E.solve(e2);</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result(0, 0) = t1[0];</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result(1, 0) = t1[1];</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result(0, 1) = t2[0];</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result(1, 1) = t2[1];</span>

        <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">or solve it by hand.</span>

        <span style="color: #5FB7CC;">auto</span> <span style="color: #ffffaa;">Ei</span> = E<span style="color: #1565C0;">(</span>i<span style="color: #1565C0;">)</span>;
        <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">den</span> = Ei<span style="color: #1565C0;">(</span>0, 0<span style="color: #1565C0;">)</span> * Ei<span style="color: #1565C0;">(</span>1, 1<span style="color: #1565C0;">)</span> - Ei<span style="color: #1565C0;">(</span>0, 1<span style="color: #1565C0;">)</span> * Ei<span style="color: #1565C0;">(</span>1, 0<span style="color: #1565C0;">)</span>;

        result<span style="color: #1565C0;">(</span>0, 0<span style="color: #1565C0;">)</span> = <span style="color: #1565C0;">(</span>e1<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>1, 1<span style="color: #EF6C00;">)</span> - e1<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>0, 1<span style="color: #EF6C00;">)</span><span style="color: #1565C0;">)</span> / den;
        result<span style="color: #1565C0;">(</span>1, 0<span style="color: #1565C0;">)</span> = <span style="color: #1565C0;">(</span>e1<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>0, 0<span style="color: #EF6C00;">)</span> - e1<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>1, 0<span style="color: #EF6C00;">)</span><span style="color: #1565C0;">)</span> / den;
        result<span style="color: #1565C0;">(</span>0, 1<span style="color: #1565C0;">)</span> = <span style="color: #1565C0;">(</span>e2<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>1, 1<span style="color: #EF6C00;">)</span> - e2<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>0, 1<span style="color: #EF6C00;">)</span><span style="color: #1565C0;">)</span> / den;
        result<span style="color: #1565C0;">(</span>1, 1<span style="color: #1565C0;">)</span> = <span style="color: #1565C0;">(</span>e2<span style="color: #EF6C00;">[</span>1<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>0, 0<span style="color: #EF6C00;">)</span> - e2<span style="color: #EF6C00;">[</span>0<span style="color: #EF6C00;">]</span> * Ei<span style="color: #EF6C00;">(</span>1, 0<span style="color: #EF6C00;">)</span><span style="color: #1565C0;">)</span> / den;

        <span style="color: #5FB7CC;">return</span> result;
    <span style="color: #e91e63;">}</span>
</pre>
</div>
<p>
This implementation, however, didn't work: the output image didn't get
warped, even if I changed the value of other parameters (e.g., u).
Remaining this problem unsolved in my mind, I 'copied' another solution to
get things done(referenced from a lab report online): set T<sub>i</sub> directly
to identity matrix, everything works as expected:
</p>
<div class="org-src-container">

<pre class="src src-c++">    <span style="color: #7FFFD4;">QPointF</span> <span style="color: #1D68C4;">fi</span><span style="color: #e91e63;">(</span><span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">p</span>, <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
        <span style="color: #7FFFD4;">QPointF</span> <span style="color: #ffffaa;">result</span>;

        result.rx<span style="color: #1565C0;">()</span> = control_points<span style="color: #1565C0;">[</span>i<span style="color: #1565C0;">]</span>.second.x<span style="color: #1565C0;">()</span> + dx<span style="color: #1565C0;">(</span>p, control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first<span style="color: #1565C0;">)</span>;
        result.ry<span style="color: #1565C0;">()</span> = control_points<span style="color: #1565C0;">[</span>i<span style="color: #1565C0;">]</span>.second.y<span style="color: #1565C0;">()</span> + dy<span style="color: #1565C0;">(</span>p, control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first<span style="color: #1565C0;">)</span>;

        <span style="color: #a5a5a5;">//</span><span style="color: #a5a5a5;">auto ti_ = ti(i);</span>

        <span style="color: #a5a5a5;">//  </span><span style="color: #a5a5a5;">fi(p) = qi + T(p - pi), where [offset = T(p - pi)]</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">double offsetx = ti_(0, 0) * dx(p, control_points[i].first) +</span>
<span style="color: #a5a5a5;">//                         </span><span style="color: #a5a5a5;">ti_(0, 1) * dy(p, control_points[i].first);</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">double offsety = ti_(1, 0) * dx(p, control_points[i].first) +</span>
<span style="color: #a5a5a5;">//                         </span><span style="color: #a5a5a5;">ti_(1, 1) * dy(p, control_points[i].first);</span>

<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result.rx() = control_points[i].second.x() + offsetx;</span>
<span style="color: #a5a5a5;">//        </span><span style="color: #a5a5a5;">result.ry() = control_points[i].second.y() + offsety;</span>


        <span style="color: #5FB7CC;">return</span> result;
    <span style="color: #e91e63;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">RBF</h3>
<div class="outline-text-3" id="text-3-2">
<div class="center">
<p>
&fnof;(p) = &sum;&alpha;<sub>i</sub>(p)&fnof;<sub>i</sub>(d(p, p<sub>i</sub>)) + P<sub>m</sub>(p);
</p>
</div>
<p>
The implementation of RBF method is relatively easy: no need to
calculate the partial derivative to find the optimal T.
</p>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Implementing P<sub>m</sub>(p)</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7FFFD4;">QPoint</span> <span style="color: #1D68C4;">pm</span><span style="color: #e91e63;">(</span><span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">p</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">identical transformation is usually sufficient</span>
    <span style="color: #5FB7CC;">return</span> p;
<span style="color: #e91e63;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Implementing &fnof;<sub>i</sub>(d(p, p<sub>i</sub>))</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7FFFD4;">double</span> <span style="color: #1D68C4;">fid</span><span style="color: #e91e63;">(</span><span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">p</span>, <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">use u = 0.5 as a default value.</span>
    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">u</span> = 0.5;

    <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">change ri_sq(i) to get a better result: e.g., ri = 100, 80, 60</span>
    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">sq_sum</span> = dis_sq<span style="color: #1565C0;">(</span>p, control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first<span style="color: #1565C0;">)</span> + ri_sq<span style="color: #1565C0;">(</span>i<span style="color: #1565C0;">)</span>;

    <span style="color: #5FB7CC;">return</span> pow<span style="color: #1565C0;">(</span>sq_sum, u<span style="color: #1565C0;">)</span>;
<span style="color: #e91e63;">}</span>

<span style="color: #7FFFD4;">double</span> <span style="color: #1D68C4;">dis_sq</span><span style="color: #e91e63;">(</span><span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">p</span>, <span style="color: #5FB7CC;">const</span> <span style="color: #7FFFD4;">QPoint</span>&amp; <span style="color: #ffffaa;">pp</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
    <span style="color: #5FB7CC;">return</span> <span style="color: #1565C0;">(</span>p.x<span style="color: #EF6C00;">()</span> - pp.x<span style="color: #EF6C00;">()</span><span style="color: #1565C0;">)</span> * <span style="color: #1565C0;">(</span>p.x<span style="color: #EF6C00;">()</span> - pp.x<span style="color: #EF6C00;">()</span><span style="color: #1565C0;">)</span> +
           <span style="color: #1565C0;">(</span>p.y<span style="color: #EF6C00;">()</span> - pp.y<span style="color: #EF6C00;">()</span><span style="color: #1565C0;">)</span> * <span style="color: #1565C0;">(</span>p.y<span style="color: #EF6C00;">()</span> - pp.y<span style="color: #EF6C00;">()</span><span style="color: #1565C0;">)</span>;
<span style="color: #e91e63;">}</span>

<span style="color: #7FFFD4;">double</span> <span style="color: #1D68C4;">ri_sq</span><span style="color: #e91e63;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span><span style="color: #e91e63;">)</span> <span style="color: #e91e63;">{</span>
    <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;

    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">min_dis_sq</span> = <span style="color: #8dd7e9;">std</span>::<span style="color: #8dd7e9;">numeric_limits</span><span style="color: #1565C0;">&lt;</span><span style="color: #7FFFD4;">double</span><span style="color: #1565C0;">&gt;</span>::max<span style="color: #1565C0;">()</span>;
    <span style="color: #7FFFD4;">double</span> <span style="color: #ffffaa;">tmp_dis_sq</span>;

    <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">j</span> = 0; j &lt; sz; ++j<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        <span style="color: #5FB7CC;">if</span> <span style="color: #EF6C00;">(</span>j == i<span style="color: #EF6C00;">)</span> <span style="color: #EF6C00;">{</span>
            <span style="color: #5FB7CC;">continue</span>;
        <span style="color: #EF6C00;">}</span>

        tmp_dis_sq = dis_sq<span style="color: #EF6C00;">(</span>control_points<span style="color: #B388FF;">[</span>i<span style="color: #B388FF;">]</span>.first, control_points<span style="color: #B388FF;">[</span>j<span style="color: #B388FF;">]</span>.first<span style="color: #EF6C00;">)</span>;

        <span style="color: #5FB7CC;">if</span> <span style="color: #EF6C00;">(</span>min_dis_sq &gt; tmp_dis_sq<span style="color: #EF6C00;">)</span> <span style="color: #EF6C00;">{</span>
            min_dis_sq = tmp_dis_sq;
        <span style="color: #EF6C00;">}</span>

    <span style="color: #1565C0;">}</span>

    <span style="color: #5FB7CC;">return</span> min_dis_sq;

<span style="color: #e91e63;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">Implementing &alpha;<sub>i</sub>(p)</h4>
<div class="outline-text-4" id="text-3-2-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">the next is to solve a system of equations, AX = b, to obtain the value of ai.</span>

<span style="color: #7FFFD4;">MatrixXd</span> <span style="color: #1D68C4;">A</span><span style="color: #e91e63;">()</span> <span style="color: #e91e63;">{</span>
    <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;

    <span style="color: #7FFFD4;">MatrixXd</span> <span style="color: #1D68C4;">a</span><span style="color: #1565C0;">(</span>sz, sz<span style="color: #1565C0;">)</span>;
    <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">row</span> = 0; row &lt; sz; ++row<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        <span style="color: #5FB7CC;">for</span> <span style="color: #EF6C00;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">col</span> = 0; col &lt; sz; ++col<span style="color: #EF6C00;">)</span> <span style="color: #EF6C00;">{</span>
            a<span style="color: #B388FF;">(</span>row, col<span style="color: #B388FF;">)</span> = fid<span style="color: #B388FF;">(</span>control_points<span style="color: #76ff03;">[</span>row<span style="color: #76ff03;">]</span>.first, col<span style="color: #B388FF;">)</span>;
        <span style="color: #EF6C00;">}</span>
    <span style="color: #1565C0;">}</span>

    <span style="color: #5FB7CC;">return</span> a;
<span style="color: #e91e63;">}</span>

<span style="color: #7FFFD4;">vector</span><span style="color: #e91e63;">&lt;</span>QPointF<span style="color: #e91e63;">&gt;</span> <span style="color: #1D68C4;">ai</span><span style="color: #e91e63;">()</span> <span style="color: #e91e63;">{</span>
    <span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">sz</span> = control_points.size<span style="color: #1565C0;">()</span>;

    <span style="color: #7FFFD4;">VectorXd</span> <span style="color: #1D68C4;">bx</span><span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">sz</span><span style="color: #1565C0;">)</span>;
    <span style="color: #7FFFD4;">VectorXd</span> <span style="color: #1D68C4;">by</span><span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">sz</span><span style="color: #1565C0;">)</span>;
    <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span> = 0; i &lt; sz; ++i<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        bx<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span> = control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.second.x<span style="color: #EF6C00;">()</span> - control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first.x<span style="color: #EF6C00;">()</span>;
        by<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span> = control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.second.y<span style="color: #EF6C00;">()</span> - control_points<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>.first.y<span style="color: #EF6C00;">()</span>;
    <span style="color: #1565C0;">}</span>


    <span style="color: #7FFFD4;">ColPivHouseholderQR</span><span style="color: #1565C0;">&lt;</span><span style="color: #7FFFD4;">MatrixXd</span><span style="color: #1565C0;">&gt;</span> <span style="color: #1D68C4;">QRed_A</span><span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">A</span><span style="color: #EF6C00;">()</span><span style="color: #1565C0;">)</span>;
    <span style="color: #7FFFD4;">VectorXd</span> <span style="color: #ffffaa;">aix</span> = QRed_A.solve<span style="color: #1565C0;">(</span>bx<span style="color: #1565C0;">)</span>;
    <span style="color: #7FFFD4;">VectorXd</span> <span style="color: #ffffaa;">aiy</span> = QRed_A.solve<span style="color: #1565C0;">(</span>by<span style="color: #1565C0;">)</span>;


    <span style="color: #7FFFD4;">vector</span><span style="color: #1565C0;">&lt;</span>QPointF<span style="color: #1565C0;">&gt;</span> <span style="color: #ffffaa;">ai_</span>;
    <span style="color: #7FFFD4;">QPointF</span> <span style="color: #ffffaa;">p</span>;
    <span style="color: #5FB7CC;">for</span> <span style="color: #1565C0;">(</span><span style="color: #7FFFD4;">int</span> <span style="color: #ffffaa;">i</span> = 0; i &lt; sz; ++i<span style="color: #1565C0;">)</span> <span style="color: #1565C0;">{</span>
        p.rx<span style="color: #EF6C00;">()</span> = aix<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>;
        p.ry<span style="color: #EF6C00;">()</span> = aiy<span style="color: #EF6C00;">[</span>i<span style="color: #EF6C00;">]</span>;
        ai_.push_back<span style="color: #EF6C00;">(</span>p<span style="color: #EF6C00;">)</span>;
    <span style="color: #1565C0;">}</span>

   <span style="color: #a5a5a5;">// </span><span style="color: #a5a5a5;">std::cout &lt;&lt; ai_.size();</span>
    <span style="color: #5FB7CC;">return</span> ai_;
<span style="color: #e91e63;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Result</h2>
<div class="outline-text-2" id="text-4">
<p>
My result is similar to the one <a href="./Report-ImageWarping.pdf">in this report</a>.
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Finally Fragmentary Thinking (FFT)</h2>
<div class="outline-text-2" id="text-5">
<p>
Why control points? I think it might be a great idea that has
recurred in many domains of Computer Science: use the local/partial
informations to deduce the whole. Another point that I get from the
idea of control points is that: we can see the image, and we are
interacting with the computer, if we know something
</p>

<p>
What does Image Warping even mean? I was confused at the beginning:
finding the mapping function based on control points is exactly an
interpolation problem, but the pixel value of every place in the
image is what we've already know! I messed something up, in fact. In
Image Warping problems, we don't change the pixel value, we move it
from one place to another, that's where mapping function comes into
play,
</p>

<p>
IDW and RBF methods work well in 2-D images, can they still work in
3-D graphics and produce funny warped counterpart? If they can not,
what methods can? Does it make sense to tackle such a problem?
</p>

<p>
Why IDW and RBF both use distance information? If we draw the
control points in a square, then we will find that the distance
information, rooted deep in our mind as a physical concept, is
apparently the most intuitive one to utilize. Think of derivative
information, not so good for this problem; Think of &#x2026; no more
examples due to my ignorance.
</p>

<p>
How could they come up with a piece of formulas in the paper just
like eating a piece of cake? Indeed, we can come up with whatever
mapping functions we like and test whether it works, correct it and
continue. Just too hard to find a suitable one.
</p>

<p>
Does it make sense to do such a task that transforming the
formulas into algorithms without understanding them? Yes, it does.
It especially does for new students who are needed to be trained. It
was the first taste of the imaging processing, QT programming and
numerical programming. It gave me a good time.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Liangzu Peng (<a href="mailto:faithofplz@hotmail.com">faithofplz@hotmail.com</a>)</p>
<p class="date">Date: 2017-02-27 Mon 13:42</p>
</div>
</body>
</html>
